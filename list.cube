List :: * -> *;
List e = forall (a::*) . a -> (e->a->a) -> a;

Nil :: forall (e::*) . List e;
Nil e = \ (a::*) (nil::a) (cons::e->a->a) -> nil;

Cons :: forall (e::*) . e -> List e -> List e;
Cons e x xs = \ (a::*) (nil::a) (cons::e->a->a) -> cons x (xs a nil cons);

foldr :: forall (a::*) (b::*) . (a->b->b) -> b -> List a -> b;
foldr a b f z xs = xs b z f;

map :: forall (a::*) (b::*) . (a->b) -> List a -> List b;
map a b f xs = foldr a (List b) (\ (x::a) (r::List b) -> Cons b (f x) r) (Nil b) xs;

append :: forall (a::*) . List a -> List a -> List a;
append a xs ys = foldr a (List a) (Cons a) ys xs;

iota :: Nat -> List Nat;
iota n =
    let LNat :: *;
    	LNat = List Nat;
        T :: *;
        T = Pair Nat LNat;
        step :: T -> T;
        step nl = split Nat LNat T
                        (\ (n::Nat) (l::LNat) -> pair Nat LNat
			   	    	     	      (Succ n) (Cons Nat n l))
			nl;
	start :: T;
	start = pair Nat LNat 0 (Nil Nat);
        res :: T;
	res = nat T step start n;
    in  snd Nat LNat res;

replicate :: forall (a::*) . Nat -> a -> List a;
replicate a n x = map Nat a (const a Nat x) (iota n);
